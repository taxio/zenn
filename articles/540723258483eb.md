---
title: "RIP-7560: Native Account Abstraction"
emoji: "👛"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["AccountAbstraction", "Ethereum"]
publication_name: "sivira_inc"
published: false
---
こんにちは。[SIVIRA Inc.](https://sivira.co/index-ja.html) で unWallet の開発をしている taxio です。

先日 ERC-4337 の Author たちから "RIP-7650 Native Account Abstraction" という Proposal が提出されました。

https://github.com/ethereum/RIPs/pull/3

description を見比べると分かりやすいですが、コンセンサスレイヤに手を入れて本格的に Native Account Abstraction を達成するための Proposal になっています。

> An account abstraction proposal which completely avoids consensus-layer protocol changes, instead relying on higher-layer infrastructure.
> -- [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)

> An account abstraction proposal that introduces consensus-layer protocol changes, instead of relying on higher-layer infrastructure.
> -- [RIP-7560](https://github.com/eth-infinitism/RIPs/blob/e8af8009251f24e67311e0d955e7a951284717fc/RIPS/rip-7560.md)

RIP という聞き慣れない prefix がありますが、これは Rollup Improvement Proposals の略で、Ethereum エコシステムにおけるロールアップの標準化を提供することを目的としています。

ただし標準とはいっても常にオプションであり、Ethereum のエコシステムとしてこれを強制するものではありません。

https://github.com/ethereum/RIPs

本記事では RIP-7650 で提案された AA の仕様を追いながら、ERC-4337 と何が違うのかを見ていきます。

## Account Abstraction おさらい
> In short, account abstraction means that not only the execution of a transaction can be arbitrarily complex computation logic as specified by the EVM, but also the authorization logic of a transaction would be opened up so that users could create accounts with whatever authorization logic they want.
> -- https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020

Account Abstraction とはユーザが Tx の認可ロジックを任意に設定できるようにすることを目標としています。

これを達成するためにいくつかの角度から Proposal が提案されています。
詳しくは以下の記事を読んでみてください。

https://zenn.dev/sivira_inc/articles/d041f1ac44ca1e

https://zenn.dev/sivira_inc/articles/34e8147f206ff5

## RIP-7560 の仕様と ERC-4337 との差分
ざっくり一言でいうと、Bundler と EntryPoint が Core にネイティブ実装されます。

ユーザはいつも通り RPC エンドポイントに対して通常の EOA 起点の Tx を投げるように、AA のリクエストを送ればその Tx が Block に格納されます。

EIP-86 や EIP-2938 で達成しようとしていた Core での AA を ERC-4337 のアイデアを軸にやり直したという感じです。

### AA Transactions
EIP-2718 に則って Account Abstraction 用の新しい Transaction Type (`AA_TX_TYPE` = 0x04) が定義されました。

payload は以下のとおりです。

```
0x04 || 0x00 || rlp([
  chainId, sender, nonce, builderFee,
  callData, paymasterData, deployerData,
  maxPriorityFeePerGas, maxFeePerGas,
  validationGasLimit, paymasterGasLimit, callGasLimit,
  accessList, signature
])
```

Transaction Hash は以下のように計算されます。

```
keccak256(AA_TX_TYPE || 0x00 || rlp(transaction_payload)
```

コントラクト上で渡ってくるデータ構造は以下のとおりです。

```solidity
struct TransactionType4 {
    address sender;
    uint256 nonce;
    uint256 validationGasLimit;
    uint256 paymasterGasLimit;
    uint256 callGasLimit;
    uint256 maxFeePerGas;
    uint256 maxPriorityFeePerGas;
    uint256 builderFee;
    bytes paymasterData;
    bytes deployerData;
    bytes callData;
    bytes signature;
}
```

UserOperation とほぼ同じような構造になっています。

以前は `maxFeePerGas` と `maxPriorityFeePerGas` は Bundler に対するガス支払いのパラメータになっていましたが、今回はネイティブ実装になるため通常のガスパラメータと同様に扱われます。

`buidlerFee` が追加されていますが、これはガス代とは別に Block builder (Block header の `coinbase`) に支払われるチップになります。
L2 Rollup などの offchain 作業では L1 に対する費用は L2 側のガス変動とは別軸で発生するため、パラメータも分離されているようです。

### 実行の流れ
大枠は ERC-4337 と変わってい無さそうです。
以下の記事で分かりやすく解説しています。

https://zenn.dev/taxio/articles/834e6a04bd6b80

ただし Core に実装された影響で Contract 上で見える Transaction Property が以下のように変化します。

* `msg.sender`: `AA_ENTRY_POINT` (`address(7560)`).
  * Sender deployment frame では `AA_SENDER_CREATOR` (`address(ffff7560)`)
* `tx.origin`: `sender` address

`tx.origin` がちゃんと Contract Account のアドレスを指すようになったのが、Native Account Abstraction っぽくていいですね。
ERC-4337 では Bundler の EOA address が入っていました。

次では ERC-4337 にも存在した Validation (Verification) Phase と Execution Phase でそれぞれ何が起きるのかを見ていきます。

#### Validation Phase
このフェーズでは全ての処理は revert することなく正常に完了する必要があります。
revert する場合、Block には取り込まれません。(そもそも Node RPC 側で弾かれるはず)
次の4つの frame から構成されます。

##### Nonce validation frame
`AA_ENTRY_POINT` が `sender` の nonce チェックを行います。
nonce のフォーマットは ERC-4337 の EntryPoint と同じ Two-dimensional nonce [^two-dimensional-nonce] です。
NonceManager がどう運用されるかは議論中のようです。

[^two-dimensional-nonce]: https://docs.google.com/document/d/1MywdH_TCkyEjD3QusLZ_kUZg4ZEI00qp97mBze9JI4k/edit

##### Sender deployment frame
`AA_SENDER_CREATOR` が `deployerData` に従って Account Contract を deploy します。

この frame での gas は `validationGasLimit` に含まれます。

##### Sender validation frame
`AA_ENTRY_POINT` が Contract Account に実装されている以下の関数を呼び出します。

```solidity
function validateTransaction(
  uint256 version,
  bytes32 txHash,
  bytes transaction
) external returns (uint256 validationData);
```

`transaction` は `TransactionType4` が ABI Encode されたものです。
将来的に Transaction の構造が変わった時にシグネチャが変更されないようになっていて、`version` がその構造体の revision を表しています。

この frame での gas は `validationGasLimit` に含まれます。

##### Paymaster validation frame
`AA_SENDER_CREATOR` が Paymaster に実装されている以下の関数を呼び出します。

```solidity
function validatePaymasterTransaction(
  uint256 version,
  bytes32 txHash,
  bytes transaction
) external returns (bytes context, uint256 validationData);
```

ここでの gas は `paymasterGasLimit` に含まれます。

#### Execution Phase
##### Sender execution frame
`AA_SENDER_CREATOR` が Contract Account に対して `callData` を invoke します。
ここで revert が起きても、Validation phase の処理は revert されません。

この frame での gas は `callGasLimit` に含まれます。

##### Paymaster post-transaction frame
`AA_SENDER_CREATOR` が Paymaster の以下の関数を呼び出します。

```solidity
function postPaymasterTransaction(
  bool success, // Sender execution frame が revert せずに完了したか
  uint256 actualGasCost,
  bytes context
) external;
```

Sender execution frame が revert されても、この frame は実行されます。

この frame での gas は `paymasterGasLimit` に含まれます。

以上が AA Transaction 実行時の流れです。
ERC-4337 と同じで Contract Account と Paymaster には特定のシグネチャを持った関数の実装が求められます。
Core 側が Contract の interface を強制しているのは面白いですね。

### Validation, Execution Tx の分離
先程も触れた通り、Validation phase は必ず revert されずに完了する必要があります。

特定の AA Tx の Execution によって他の AA Tx の Validation が revert される状態になる可能性があるので、Block 構築の難易度緩和のために Block builder は Validation phase と Execution phase で Tx を分割することができます。

> ![block overview](/images/540723258483eb/block_overview.png)
> -- https://github.com/eth-infinitism/RIPs/blob/e8af8009251f24e67311e0d955e7a951284717fc/RIPS/rip-7560.md#block-structure-diagram

このとき Validation phase 側の Tx が Virtual Transaction と呼ばれ、Tx Hash は `AA_TX_TYPE transaction hash + 1`、つまり Execution phase 側の Tx Hash に1を足したものになります。

## 既に Native AA をサポートしている L2
RIP-7560 では ERC-4337 をベースに非常にシンプルに Account Abstraction を Core に実装していました。

ところで、この Proposal が出されるより前に既に Account Abstraction のネイティブ実装を入れているチェーンが存在します。
先発の実装はどうなっているのかいくつか見てみましょう。

### zkSync
https://era.zksync.io/docs/reference/concepts/account-abstraction.html

* SystemContract が実質 Core の実装
* 思想は変わらない

### StarkNet
https://docs.starknet.io/documentation/architecture_and_concepts/Accounts/approach/

https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md

https://perama-v.github.io/cairo/account-abstraction/

* 内部でどういった実装をしているのかは分からないが、validate, execute 関数を持っていて、validate が通ったら execute を通すという流れは変わらないし、Core 側でそのハンドリングをやっていそう

### 今後の L2 対応についての考察
* Core 側で EntryPoint に該当する機能を持ち、Contract Account では validate, execute の関数を持つという方針は変わらない
* RIP で方向性が示され始めたため、ここに一定収束していくのではないか？
* Wallet provider として、chain 毎に Contract Account の interface が異なるのは困る

## 終わりに
RIP-7560 の仕様を見ていきました。
ERC-4337 の慣れ親しんだ (?) アーキテクチャでシンプルに Core に実装されていて、これならギャップも少なく現実的な解なのではないかと思えますね。
