---
title: "RIP-7560: Native Account Abstraction"
emoji: "👛"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["AccountAbstraction", "Ethereum"]
publication_name: "sivira_inc"
published: false
---

先日 ERC-4337 の Author たちから "RIP-7650 Native Account Abstraction" という Proposal が提出されました。

https://github.com/ethereum/RIPs/pull/3

description を見比べると分かりやすいですが、コンセンサスレイヤに手を入れて本格的に Native Account Abstraction を達成するための Proposal になっています。

> An account abstraction proposal which completely avoids consensus-layer protocol changes, instead relying on higher-layer infrastructure.
> -- [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)

> An account abstraction proposal that introduces consensus-layer protocol changes, instead of relying on higher-layer infrastructure.
> -- [RIP-7560](https://github.com/eth-infinitism/RIPs/blob/e8af8009251f24e67311e0d955e7a951284717fc/RIPS/rip-7560.md)

RIP という聞き慣れない prefix がありますが、これは Rollup Improvement Proposals の略で、Ethereum エコシステムにおけるロールアップの標準化を提供することを目的としています。

ただし標準とはいっても常にオプションであり、Ethereum のエコシステムとしてこれを強制するものではありません。

https://github.com/ethereum/RIPs

本記事では RIP-7650 で提案された AA の仕様を追いながら、ERC-4337 と何が違うのかを見ていきます。

## Account Abstraction おさらい
> In short, account abstraction means that not only the execution of a transaction can be arbitrarily complex computation logic as specified by the EVM, but also the authorization logic of a transaction would be opened up so that users could create accounts with whatever authorization logic they want.
> -- https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020

Account Abstraction とはユーザが Tx の認可ロジックを任意に設定できるようにすることを目標としています。

これを達成するためにいくつかの角度から Proposal が提案されています。
詳しくは以下の記事を読んでみてください。

https://zenn.dev/sivira_inc/articles/d041f1ac44ca1e

https://zenn.dev/sivira_inc/articles/34e8147f206ff5

## RIP-7560 の仕様と ERC-4337 との差分
ざっくり一言でいうと、Bundler と EntryPoint が Core にネイティブ実装されます。

ユーザはいつも通り RPC エンドポイントに対して通常の EOA 起点の Tx を投げるように、AA のリクエストを送ればその Tx が Block に格納されます。

EIP-86 や EIP-2938 で達成しようとしていた Core での AA を ERC-4337 のアイデアを軸にやり直したという感じです。

### AA Transactions
以下が Account Absraction 用の新しい Transaction Type です。
```solidity
struct TransactionType4 {
    address sender;
    uint256 nonce;
    uint256 validationGasLimit;
    uint256 paymasterGasLimit;
    uint256 callGasLimit;
    uint256 maxFeePerGas;
    uint256 maxPriorityFeePerGas;
    uint256 builderFee;
    bytes paymasterData;
    bytes deployerData;
    bytes callData;
    bytes signature;
}
```

UserOperation とほぼ同じような Payload になっています。

以前は `maxFeePerGas` と `maxPriorityFeePerGas` は Bundler に対するガス支払いのパラメータになっていましたが、今回はネイティブ実装になるため通常のガスパラメータと同様に扱われます。

`buidlerFee` が追加されていますが、これはガス代とは別で Block builder (Block header の `coinbase`) に支払われるチップになります。
L2 Rollup などの offchain 作業では L1 に対する費用は L2 側のガス変動とは別軸で発生するため、パラメータも分離されているようです。

### 実行の流れ
大枠は ERC-4337 と変わってい無さそうです。
以下の記事で分かりやすく解説しています。

https://zenn.dev/taxio/articles/834e6a04bd6b80

ただし Contract 上で見える Transaction Property が以下のように少し変わります。

* `msg.sender`: `AA_ENTRY_POINT` (`address(7560)`).
  * Sender deployment frame では `AA_SENDER_CREATOR` (`address(ffff7560)`)
* `tx.origin`: `sender` address

`tx.origin` がちゃんと Contract Account のアドレスを指すようになったのが、Native Account Abstraction っぽくていいですね。
ERC-4337 では Bundler の EOA address が入っていました。

#### Validation Phase
このフェーズでは全ての frame は revert することなく正常に完了する必要がある。

* Nonce validation frame
  * EntryPoint と同じ Two-dimensional nonce [^two-dimensional-nonce]
  * どうやって運用されるかは議論中
* Sender deployment frame
  * `validationGasLimit` を消費
  * `AA_SENDER_CREATOR` が `deployerData` に従って Account Contract を deploy する
* Sender validation frame
  * `validationGasLimit` を消費
  * `function validateTransaction(uint256 version, bytes32 txHash, bytes transaction) external returns (uint256 validationData);`
* Paymaster validation frame
  * `paymasterGasLimit` を消費
  * `function validatePaymasterTransaction(uint256 version, bytes32 txHash, bytes transaction) external returns (bytes context, uint256 validationData);`

[^two-dimensional-nonce]: https://docs.google.com/document/d/1MywdH_TCkyEjD3QusLZ_kUZg4ZEI00qp97mBze9JI4k/edit

#### Execution Phase
* Sender execution frame
  * `callGasLimit` を消費
  * `sender` に対して `callData` が invoke される
  * この execution frame が revert されても、validation frame は revert されない
* Paymaster post-transaction frame
  * `paymasterGasLimit` を消費
  * `function postPaymasterTransaction(bool success, uint256 actualGasCost, bytes context) external;`
    * `success` は直前の execution frame が成功したかどうか

### Validation, Execution Tx の分離
* Builder は AA Tx を Validation, Execution の2つの Tx に分離することができる

### RPC への実装追加
* `eth_sendTransaction`, `eth_sendRawTransaction`
  * `AA_TYPE_TX` に対応
* `eth_signTransaction`
  * `AA_TX_TYPE` を受け入れ、signature を埋めるようになる
* `eth_getTransactionReceipt`
  * `AA_TX_TYPE` に対応
  * Validation phase 側の Tx hash で取得が可能
* `eth_call`
  * `AA_TX_TYPE` に対応
* `eth_estimateGasAccountAbstraction` (New)
  * `AA_TX_TYPE` に対応
  * `validationGasLimit`, `paymasterGasLimit`, `callGasLimit`, `builderFee` が取得可能
    * `builderFee` を返しているのは、L2 側が一定値を指定することを想定しているのだろうか？

## Native AA をサポートしている L2 との比較
### zkSync

### StarkNet

### 今後の L2 対応についての考察

## 終わりに

### 関連 Proposal
* [ERC-2938]()
* [ERC-4337]()
* [ERC-7562](https://github.com/ethereum/ERCs/pull/105)
  * Validation フェーズが失敗しない AA Tx でないと Block に格納することはできないので、mempool に invalid な Tx を大量に流すことで Block builder に対する飽和攻撃が可能になる。それを止めるために具体的な mempool 配信に関する Validation ルールと Reputation ルールを定めている。
* [ERC-5003]()
* [ERC-6913]()
* [ERC-7377]()
